/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalloutInserterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultCalloutTypes: [
    "note",
    "abstract",
    "info",
    "todo",
    "tip",
    "success",
    "question",
    "warning",
    "failure",
    "danger",
    "bug",
    "example",
    "quote",
    "summary"
  ]
};
var CalloutInserterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.cssCalloutTypes = [];
  }
  async onload() {
    await this.loadSettings();
    this.parseCalloutTypesFromCSS();
    this.addCommand({
      id: "insert-callout",
      name: "Insert callout...",
      editorCallback: (editor, view) => {
        new CalloutSuggestModal(
          this.app,
          editor,
          this.getAvailableCalloutTypes()
        ).open();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "c"
        }
      ]
    });
    this.addSettingTab(new CalloutInserterSettingTab(this.app, this));
  }
  parseCalloutTypesFromCSS() {
    const cssPath = `${this.app.vault.configDir}/snippets/callouts.css`;
    this.app.vault.adapter.read(cssPath).then((content) => {
      const regex = /\[data-callout=["']([^"']+)["']\]/g;
      const matches = content.matchAll(regex);
      const types = /* @__PURE__ */ new Set();
      for (const match of matches) {
        types.add(match[1]);
      }
      this.cssCalloutTypes = Array.from(types);
      console.log("Found callout types in CSS:", this.cssCalloutTypes);
    }).catch((err) => {
      console.log("Could not read callouts.css, using defaults:", err);
      this.cssCalloutTypes = [];
    });
  }
  getAvailableCalloutTypes() {
    const combined = [
      ...this.cssCalloutTypes,
      ...this.settings.defaultCalloutTypes
    ];
    return Array.from(new Set(combined)).sort();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CalloutSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, editor, calloutTypes) {
    super(app);
    this.currentPreviewType = null;
    this.editor = editor;
    this.calloutTypes = calloutTypes;
    this.component = new import_obsidian.Component();
    this.setPlaceholder("Type to search for a callout type...");
    this.createPreviewContainer();
  }
  onOpen() {
    super.onOpen();
    this.observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          const target = mutation.target;
          if (target.classList.contains("is-selected")) {
            const type = target.dataset.calloutType;
            if (type)
              this.updatePreview(type);
          }
        }
      }
    });
    this.observer.observe(this.resultContainerEl, {
      subtree: true,
      attributes: true,
      attributeFilter: ["class"]
    });
  }
  createPreviewContainer() {
    const modalEl = this.modalEl;
    this.previewEl = modalEl.createDiv("callout-preview-container");
    this.previewEl.style.padding = "1em";
    this.previewEl.style.borderTop = "1px solid var(--background-modifier-border)";
    this.previewEl.style.height = "auto";
    this.previewEl.style.minHeight = "130px";
    this.previewEl.style.overflow = "auto";
  }
  getItems() {
    return this.calloutTypes;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.insertCallout(item);
  }
  insertCallout(type) {
    const cursor = this.editor.getCursor();
    const calloutText = `> [!${type}]
> `;
    this.editor.replaceRange(calloutText, cursor);
    const newCursor = {
      line: cursor.line + 1,
      ch: 2
    };
    this.editor.setCursor(newCursor);
    this.editor.focus();
  }
  renderSuggestion(match, el) {
    const item = match.item;
    el.createEl("div", { text: item });
    el.dataset.calloutType = item;
    el.addEventListener("mouseenter", () => {
      this.updatePreview(item);
    });
    if (el.classList.contains("is-selected")) {
      this.updatePreview(item);
    }
  }
  async updatePreview(type) {
    if (this.currentPreviewType === type)
      return;
    this.currentPreviewType = type;
    this.previewEl.empty();
    const calloutMarkdown = `> [!${type}] ${type.charAt(0).toUpperCase() + type.slice(1)}
> This is a preview of the ${type} callout.`;
    await import_obsidian.MarkdownRenderer.render(
      this.app,
      calloutMarkdown,
      this.previewEl,
      "",
      this.component
    );
  }
  onClose() {
    super.onClose();
    this.component.unload();
    if (this.observer) {
      this.observer.disconnect();
    }
  }
};
var CalloutInserterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Callout Inserter Settings" });
    new import_obsidian.Setting(containerEl).setName("Refresh callout types from CSS").setDesc("Re-scan the callouts.css file for available callout types").addButton(
      (button) => button.setButtonText("Refresh").onClick(async () => {
        this.plugin.parseCalloutTypesFromCSS();
        button.setButtonText("Refreshed!");
        setTimeout(() => button.setButtonText("Refresh"), 2e3);
      })
    );
    containerEl.createEl("h3", { text: "Found Callout Types" });
    const typesEl = containerEl.createEl("div", {
      cls: "callout-types-list",
      text: this.plugin.getAvailableCalloutTypes().join(", ") || "None found"
    });
    typesEl.style.padding = "1em";
    typesEl.style.backgroundColor = "var(--background-secondary)";
    typesEl.style.borderRadius = "5px";
  }
};
